# docker-compose.yaml

version: '3.7'
services: 


  server:
    image: traefik:v2.3
    volumes:
      - /etc/localtime:/etc/localtime
      - /var/run/docker.sock:/var/run/docker.sock
      - /etc/ssl/certs/:/etc/ssl/certs/
      - '{{ app_data }}/certs:/etc/traefik/certs/'
      - '{{ app_data }}/traefik.yaml:/etc/traefik/dynamic/traefik.yaml:ro'
    ports:
      - 80:80
      - 443:443
    command:
      # Logging
      - '--log.level=DEBUG'
      - '--accesslog=true'

      # Enable dashboard
      - '--api=true'
      - '--api.dashboard=true'

      # Traefik Pilot registration (centralized view)
      - --pilot.token={{ traefik_pilot_token }}

      # Docker swarm configuration
      - '--providers.docker=true'
      - '--providers.docker.endpoint=unix:///var/run/docker.sock'
      - '--providers.docker.swarmMode=true'
      - '--providers.docker.exposedbydefault=false'
      - '--providers.docker.network={{ docker_network }}'
      - '--providers.docker.watch=true'

      # File provider
      - '--providers.file=true'
      - '--providers.file.directory=/etc/traefik/dynamic'
      - '--providers.file.watch=true'

      # Configure entrypoint
      - '--entrypoints.web.address=:80'
      - '--entrypoints.websecure.address=:443'

      # needed to enable TLS, unless a cert-resolver (ACME) is used
      - '--entrypoints.websecure.http.tls=true'

      # Global HTTP -> HTTPS
      - '--entrypoints.web.http.redirections.entryPoint.to=websecure'
      - '--entrypoints.web.http.redirections.entryPoint.scheme=https'
      
      # Send `X-Forwarded-*` headers to backends
      #- '--entryPoints.web.forwardedHeaders.insecure'
      #- '--entryPoints.websecure.forwardedHeaders.insecure'

      # Public cert resolver (Let's Encrypt)
      - '--certificatesresolvers.lets-encrypt.acme.httpchallenge=true'
      - '--certificatesresolvers.lets-encrypt.acme.httpchallenge.entrypoint=web'
      - '--certificatesresolvers.lets-encrypt.acme.email={{ acme_email }}'
      - '--certificatesresolvers.lets-encrypt.acme.storage=acme.json'
      - '--certificatesresolvers.lets-encrypt.acme.caServer={{ acme_url_external }}'

      # Private cert resolver (Step CA)
      - '--certificatesresolvers.step-ca.acme.httpchallenge=true'
      - '--certificatesresolvers.step-ca.acme.httpchallenge.entrypoint=web'
      - '--certificatesresolvers.step-ca.acme.email={{ acme_email }}'
      - '--certificatesresolvers.step-ca.acme.storage=acme.json'
      - '--certificatesresolvers.step-ca.acme.caServer={{ acme_url_internal }}'
      
    deploy:
      restart_policy:
        condition: any
      placement:
        constraints:
          - node.role == manager
      labels:
        # Expose dashboard at: /dashboard/ 
        # note: trailing slash must be included
        - traefik.enable=true

        # required in swarm, but can be any port number. 
        # I do not understand why this would be required..
        # Maybe it is the EGRESS port number?
        - traefik.http.services.api@internal.loadbalancer.server.port=8080
        - traefik.http.routers.dashboard.tls.certresolver=step-ca
        #- traefik.http.routers.dashboard.service=api@internal
        
        # router rules must be defined within a single docker label
        - traefik.http.routers.dashboard.rule=Host(`{{ domains | join(',') }}`) && (PathPrefix(`/dashboard`) || PathPrefix(`/api`))
        
        # middlewares
        - traefik.http.middlewares.dashboard-auth.basicauth.users={{ htpasswd }}
        - traefik.http.routers.dashboard.middlewares=dashboard-auth

    networks:
      - {{ docker_network }}

  hello:
    image: nginxdemos/hello
    deploy:
      labels:
        - traefik.enable=true
        - traefik.http.services.hello.loadbalancer.server.port=80
        - traefik.http.routers.hello.tls.certresolver=step-ca
        - traefik.http.routers.hello.rule=Host(`{{ domains | join(',') }}`) && PathPrefix(`/hello`)
        - traefik.http.middlewares.hello.stripprefix.prefixes=/hello
    networks:
      - {{ docker_network }}

networks:
  {{ docker_network }}:
    external:
      name: {{ docker_network }}
